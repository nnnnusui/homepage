# コンパイラを、書いていこうな……
　どうすりゃいいんだ……。

# エントリポイントを書けるようにしよう
　まあまずは呼び出す場所を定義出来ないといけないと思うので、そうする。

@code main.ik
  f KernelMain: void = {
    // ここにコードを書く……
  }

　@link ikata-lang https://github.com/nnnnusui/ikata|。
拡張子は`.ik`。これのパーサーを書こう。
　ここで突如TypeScriptを持ち出してきてパーサーを書きます。
　名前とか構文どうしようって延々悩んでしまった。
後々必要に応じていっぱい変えていくつもりでやっていかなきゃとは思っているんだけど、
最初から細かいところを気にし始めてしまう悪い癖が出るなどした。

　下に記したが、だいたいこんな感じに書いた。
ほんとは空白や改行を許容するとか、
パース結果をトークンに変換するとかをやるのでもっと複雑。
@code defineFunction.ts
  const defineFunction = chainN(
    chainR(sames("f "), {name}),
    option(chainR(sames(":"), {type})),
    chainN(
      sames("="),
      sames("{"),
      {function literal},
      sames("}")
    ),
  );
  defineFunction("f main: void = {test} ")
  // ["main", "void", "test"]

# LLVM-IRコードをそのまま埋め込む構文
　雑なんだけどこんな感じで、コンパイル結果にそのまま埋め込む構文を
定義しちゃう。関数の中身はともかく、`target triple` はずっとこの記法になるかなぁ。
という感じ。
@code main.ik
  raw("
  |target triple = "x86_64-unknown-unknown-elf"
  ")
  f KernelMain: void = {
    raw("
    |  br label %1
    |1:
    |  call void asm sideeffect "hlt", ""()
    |  br label %1
    ")
  }

  # Text literal
  　ダブルクォーテーションとパイプで構成されるテキストリテラルの
  パーサー(トークナイザー)を書く。細部は省くけど、トークナイズの例まで示すとこんな感じ。
  　パイプ無しでも次のダブルクォ—トまでを値として読むをやるので、paledOrCloseなんていう
  ちょっとわかんない変数名になっている。(命名ﾑｽﾞ)
  @code textLiteral.ts
    const syntax = chainR(sames('"'), chainL({paledOrClose}, sames('"')));
    const textLiteral = tokenize(syntax, (it) =>
      ({ kind: "text literal", value: it })
    );

  　値のリテラル、取り敢えずの最小の単位なので、ここでテストも書いちゃう。
  　書いた(
  @link 45beb3 https://github.com/nnnnusui/ikata/commit/45beb3422c7054d64a784b581db28cc1842c7ba2|
  )。`mocha`, `chai` を使っている。

  # Raw literal
  　次に`raw("")`構文の定義。RawLiteral(
  @link 81e4a5 https://github.com/nnnnusui/ikata/commit/81e4a5d7c0e7d319459459837ab963f52502e83a|
  )トークン。
  @code rawLiteral.ts
    const rawLiteral = chainR(
      sames("raw("),
      chainL(textLiteral, sames(")"))
    );
  　現時点では全てパーサーにハードコーディングされたデータで解釈するので、なんというか全部リテラルだね。

# 関数内に処理を入れられるようにする
  # Function literal
  　関数宣言の右辺の構文定義。
  @code functionLiteral.ts
    const functionLiteral = chainR(
      sames("{"),
      chainL(option(orders), sames("}"))
    );
  　ordersの中身は今のところ`RawLiteral`しか無い。
  　テストコード書きやすいようにするなどもしている(
  @link 047947 https://github.com/nnnnusui/ikata/commit/047947bb5fd159782681ce64ef1749a4ee738261|
  )。

  # Define function
  　最初の関数宣言の右辺に`FunctionLiteral`が来るように規定して、一先ず関数宣言の完成。

# 最上層(ファイル単位)のパース
@code main.ts
  const topLevel = or(defineFunction, rawLiteral);
  const syntax = repeat(chainR(option(interval), topLevel));
  const parse = (source: string) => syntax(source);
  // run parse(`ここにソースコード`)
　こう。

# このままコンパイル(トランスパイル)までやり
　やった(
@link 81d715 https://github.com/nnnnusui/ikata/commit/81d715e44de99fe9ef428af0a16e1842d4e3cd01|
)。このトランスパイル処理のいい感じの書き方わかんない。
後々いい感じになってくれると思う。知らんけど。

# コマンドにしますか？
　しましょうか。`cac`, `glob` を依存に追加してやります。
　やりました(
@link 24af6b https://github.com/nnnnusui/ikata/commit/24af6b07aefb869ca358d0f25cae4802d3dd348b|
)。
@code compileCommandSyntax
  ikatac -o <outputRoot> <inputRoot>
　ファイル指定ならそれを、ディレクトリ指定ならそれ以下に属する全ての
`.ik`ファイルを対象としてコンパイルする。
　outputRootの指定が無ければ各`.ik`ファイルと同じディレクトリに、
あれば {outputRoot + 各`.ik`ファイルのinputRootからの相対パス} に
`.ll`ファイルを出力する。

# 実行
　これ、
@link 読書 ./1618939566.html|
中に脇道に逸れた形で、つまりこのコードはコンパイルしてリンクしたら
`kernel.elf`と命名してブートローダーから読んで実行する。
　現時点、見かけじゃ動いてるかわからないので、qemuなんかで実行する。
@code qemu
  info registers
  x /5i 0x{ここにRIPレジスタの値-1}
　正しいLLVM-IRを吐けていれば無限ループが観測できる。

　今回はここまで。

# おわり
　なんでこの文脈(
@link 読書 ./1618939566.html|
)でいきなり言語自作やり始めたの？
　や、やりたかったから…………。
　↑ この文、前々回の時には書いてたんだけどここまで延期しちゃった。
　次はwhile? for? その前にif? トランスパイル先の %数値, :数値 はどう解決するの？
次回、プロジェクト、ﾀﾋす(頓挫)！w
　あとはちょっと進んだらUSBとかで詰みそうな気がするんですが。
まあオブジェクトファイル生成してるわけだし、ふつーにライブラリ呼べるのかな……。

@list links
  @link ikata-lang@0.1.2 https://github.com/nnnnusui/ikata/tree/v0.1.2|
    `いかた`って何さ。なんだろうね〜。
  @link combinator-node https://github.com/nnnnusui/combinator-node|
    　ぱーすに使った。
    　ぶよぐのぱーさもこれに依存させたいな。めんどいな。
  @link deno.combinator https://github.com/nnnnusui/deno.combinator|
    　Denoで書こうとした名残り。
    でもvscodeで"syntax highlight"したいとか思うと、結局nodeに移行してたんだなぁ。
